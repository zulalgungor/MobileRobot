# -*- coding: utf-8 -*-
"""Colab'e hoş geldiniz.

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb

# Yeni Bölüm
"""

# -*- coding: utf-8 -*-
"""
# =========================================================
#  RRT + LIDAR + 2 TEKERLİ NON-HOLONOMIC ROBOT (40x30)  - PYTHON
#  - Global yol planlama: RRT (occupancy grid üstünde çarpışma kontrolü)
#  - Robot: diferansiyel tahrikli, non-holonomik
#  - Lidar: 20 ışın, sarı (sadece engele çarptığında çizilir)
#  - Yol: robot hareket ettikçe beyaz iz çizilir
#  + Colab uyumlu animasyon + grafikler (metrikler)
# =========================================================
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from matplotlib.animation import FuncAnimation

# (Notebook/Colab içinde animasyonu gömmek için)
try:
    from IPython.display import HTML, display
    _HAVE_IPY = True
except Exception:
    _HAVE_IPY = False


# -----------------------------
# Yardımcı fonksiyonlar
# -----------------------------
def wrap_to_pi(a: float) -> float:
    return (a + np.pi) % (2*np.pi) - np.pi

def force_free_around(occ: np.ndarray, idx_xy: tuple[int,int], r: int) -> np.ndarray:
    occ2 = occ.copy()
    ny, nx = occ2.shape
    cx, cy = idx_xy
    x1 = max(0, cx - r); x2 = min(nx - 1, cx + r)
    y1 = max(0, cy - r); y2 = min(ny - 1, cy + r)
    occ2[y1:y2+1, x1:x2+1] = False
    return occ2

def cast_ray(pos_xy: tuple[float,float], angle: float, occ: np.ndarray, res: float, max_range: float):
    ny, nx = occ.shape
    x0, y0 = pos_xy
    step = res / 2.0

    for d in np.arange(0.0, max_range + 1e-9, step):
        x = x0 + d*np.cos(angle)
        y = y0 + d*np.sin(angle)

        ix = int(np.floor(x/res))
        iy = int(np.floor(y/res))

        if ix < 0 or ix >= nx or iy < 0 or iy >= ny:
            return x0, y0, False

        if occ[iy, ix]:
            return x, y, True

    return x0, y0, False


# -----------------------------
# RRT yardımcıları
# -----------------------------
def point_free(p, occ, res, margin_cells=0):
    """p=(x,y) noktası serbest mi?"""
    x, y = float(p[0]), float(p[1])
    ny, nx = occ.shape
    ix = int(np.floor(x/res))
    iy = int(np.floor(y/res))
    if ix < 0 or ix >= nx or iy < 0 or iy >= ny:
        return False
    # opsiyonel marj (ekstra güvenlik)
    x1 = max(0, ix - margin_cells); x2 = min(nx-1, ix + margin_cells)
    y1 = max(0, iy - margin_cells); y2 = min(ny-1, iy + margin_cells)
    return not occ[y1:y2+1, x1:x2+1].any()

def segment_free(p1, p2, occ, res):
    """p1->p2 segmenti çarpışmasız mı? (occ üzerinde örnekleme)"""
    p1 = np.array(p1, dtype=float)
    p2 = np.array(p2, dtype=float)
    dist = float(np.hypot(*(p2 - p1)))
    if dist < 1e-9:
        return point_free(p1, occ, res)
    step = res / 2.0
    n = int(np.ceil(dist / step))
    for i in range(n+1):
        a = i / max(1, n)
        p = p1*(1-a) + p2*a
        if not point_free(p, occ, res):
            return False
    return True

def rrt_plan(start, goal, occ, res, bounds, *,
             step_len=0.8, goal_sample_rate=0.10,
             max_iter=8000, goal_tol=0.6, seed=None):
    """
    Basit RRT:
    - start, goal: (x,y) metre
    - bounds: (xmin, xmax, ymin, ymax)
    - Çıkış: path listesi [(x,y), ...] veya []
    """
    rng = np.random.default_rng(seed)
    xmin, xmax, ymin, ymax = bounds

    start = np.array(start, dtype=float)
    goal  = np.array(goal,  dtype=float)

    if not point_free(start, occ, res) or not point_free(goal, occ, res):
        return []

    nodes = [start]
    parents = [-1]

    def nearest_index(p):
        pts = np.vstack(nodes)
        d = np.sum((pts - p)**2, axis=1)
        return int(np.argmin(d))

    for _ in range(max_iter):
        # örnekleme (goal bias)
        if rng.random() < goal_sample_rate:
            rnd = goal
        else:
            rnd = np.array([rng.uniform(xmin, xmax), rng.uniform(ymin, ymax)], dtype=float)

        ni = nearest_index(rnd)
        near = nodes[ni]
        v = rnd - near
        norm = float(np.hypot(v[0], v[1]))
        if norm < 1e-9:
            continue
        v = v / norm

        newp = near + v * step_len
        newp[0] = np.clip(newp[0], xmin, xmax)
        newp[1] = np.clip(newp[1], ymin, ymax)

        # çarpışma kontrolü
        if not segment_free(near, newp, occ, res):
            continue

        nodes.append(newp)
        parents.append(ni)

        # goal'e yakın mı + bağlanabilir mi?
        if float(np.hypot(*(newp - goal))) <= goal_tol and segment_free(newp, goal, occ, res):
            nodes.append(goal)
            parents.append(len(nodes)-2)  # goal parent = newp

            # path çıkar
            path = []
            cur = len(nodes) - 1
            while cur != -1:
                path.append(nodes[cur].copy())
                cur = parents[cur]
            path.reverse()
            return [tuple(p) for p in path]

    return []

def densify_path(path_points, factor=5):
    """path'i lineer interpolasyonla sıklaştırır"""
    P = np.array(path_points, dtype=float)
    if P.shape[0] < 2:
        return P
    N = P.shape[0]
    t_old = np.arange(N)
    t_new = np.linspace(0, N-1, factor*N)
    return np.column_stack([
        np.interp(t_new, t_old, P[:,0]),
        np.interp(t_new, t_old, P[:,1]),
    ])


# -----------------------------
# Robot parametreleri
# -----------------------------
R = 0.1
L = 0.5

# -----------------------------
# Ortam boyutları & ölçek
# -----------------------------
envW = 40.0
envH = 30.0
scaleX = envW/20.0   # 2
scaleY = envH/20.0   # 1.5

# -----------------------------
# Renkler
# -----------------------------
room_bg   = (0, 0, 0)
wall_col  = (0.25, 0.00, 0.40)
path_col  = (1, 1, 1)
lidar_col = (1, 1, 0)

# -----------------------------
# Duvarlar (20x20 taban -> 40x30 ölçek)
# -----------------------------
walls_base = []
walls_base += [
    [2,  2,  3, 18],
    [17, 2, 18, 18],
    [2, 17, 18, 18],
    [2,  2, 18,  3],
]
walls_base += [
    [6,  3,  7,  9],
    [6, 11,  7, 17],
    [10, 2, 11,  7],
    [10, 9, 11, 17],
    [14, 3, 15, 11],
    [14,13, 15, 17],
]
walls_base = np.array(walls_base, dtype=float)

walls = walls_base.copy()
walls[:, [0,2]] *= scaleX
walls[:, [1,3]] *= scaleY

# -----------------------------
# Başlangıç & hedef
# -----------------------------
start_base = np.array([4, 6], dtype=float)
goal_base  = np.array([16, 15], dtype=float)

start = np.array([start_base[0]*scaleX, start_base[1]*scaleY], dtype=float)
goal  = np.array([ goal_base[0]*scaleX,  goal_base[1]*scaleY], dtype=float)

# -----------------------------
# Occupancy grid (+ şişirme)
# -----------------------------
res = 0.2
nx = int(round(envW/res))
ny = int(round(envH/res))
occ = np.zeros((ny, nx), dtype=bool)

x_idx, y_idx = np.meshgrid(np.arange(nx), np.arange(ny))
xC = (x_idx + 0.5) * res
yC = (y_idx + 0.5) * res

for w in walls:
    x1,y1,x2,y2 = w
    in_rect = (xC >= x1) & (xC <= x2) & (yC >= y1) & (yC <= y2)
    occ[in_rect] = True

robot_radius = R
inflate_cells = int(np.ceil(robot_radius/res))

inflated = occ.copy()
ys, xs = np.where(occ)
for (yy, xx) in zip(ys, xs):
    x1 = max(0, xx - inflate_cells); x2 = min(nx-1, xx + inflate_cells)
    y1 = max(0, yy - inflate_cells); y2 = min(ny-1, yy + inflate_cells)
    inflated[y1:y2+1, x1:x2+1] = True
occ = inflated

# start/goal çevresini zorla boşalt (grid indeks üzerinden)
start_idx = (int(np.floor(start[0]/res)), int(np.floor(start[1]/res)))
goal_idx  = (int(np.floor(goal[0]/res)),  int(np.floor(goal[1]/res)))
occ = force_free_around(occ, start_idx, r=2)
occ = force_free_around(occ, goal_idx,  r=2)

# =========================================================
#  RRT ile yol
# =========================================================
bounds = (0.0, envW, 0.0, envH)

path_points = []
# RRT bazen takılabilir: birkaç deneme yapalım
for trial in range(1, 6):
    path = rrt_plan(
        start, goal, occ, res, bounds,
        step_len=0.9,            # düğüm adımı (çok büyük olursa çarpışma artar)
        goal_sample_rate=0.12,   # goal bias
        max_iter=9000,
        goal_tol=0.7,
        seed=trial*123
    )
    if len(path) > 0:
        path_points = np.array(path, dtype=float)
        print(f"RRT yol bulundu. Deneme={trial}, düğüm={path_points.shape[0]}")
        break

if len(path_points) == 0:
    raise RuntimeError("RRT yol bulamadı! (step_len/max_iter/goal_sample_rate ile oyna)")

# yolu sıklaştır
path_points = densify_path(path_points, factor=8)

# =========================================================
#  1) SİMÜLASYONU ÇALIŞTIR + LOG TOPLA
# =========================================================
dt = 0.2
v_ref = 0.8
k_theta = 1.5
goal_tol = 0.4
max_steps = 3000

max_range = 3.0
num_beams = 20
angles_body = np.linspace(-np.pi, np.pi, num_beams)

pose = np.array([start[0], start[1], 0.0], dtype=float)

xs_log, ys_log, th_log = [], [], []
dist_log, therr_log = [], []
v_log, w_log, wR_log, wL_log = [], [], [], []
lidar_hits_log = []
lidar_segs_log = []

reached_step = None

for step in range(1, max_steps+1):
    rx, ry, th = pose

    dist = float(np.hypot(rx - goal[0], ry - goal[1]))

    if dist < goal_tol:
        reached_step = step
        lidar_segs_log.append([])
        lidar_hits_log.append(0)
        xs_log.append(rx); ys_log.append(ry); th_log.append(th)
        dist_log.append(dist); therr_log.append(0.0)
        v_log.append(0.0); w_log.append(0.0); wR_log.append(0.0); wL_log.append(0.0)
        break

    # path üzerinde en yakın + look-ahead
    dists = np.hypot(path_points[:,0] - rx, path_points[:,1] - ry)
    path_idx_follow = int(np.argmin(dists))
    look_ahead_idx = min(path_idx_follow + 20, path_points.shape[0] - 1)
    target = path_points[look_ahead_idx]

    dx = target[0] - rx
    dy = target[1] - ry
    theta_des = float(np.arctan2(dy, dx))
    theta_err = float(wrap_to_pi(theta_des - th))

    v = float(v_ref)
    w = float(np.clip(k_theta * theta_err, -1.0, 1.0))

    rx = rx + v*np.cos(th)*dt
    ry = ry + v*np.sin(th)*dt
    th = th + w*dt
    pose = np.array([rx, ry, th], dtype=float)

    wR = float((2*v + L*w) / (2*R))
    wL = float((2*v - L*w) / (2*R))

    hit_segs = []
    hit_count = 0
    for ab in angles_body:
        global_ang = th + ab
        hx, hy, hit = cast_ray((rx, ry), global_ang, occ, res, max_range)
        if hit:
            hit_count += 1
            hit_segs.append((rx, ry, hx, hy))
    lidar_segs_log.append(hit_segs)
    lidar_hits_log.append(hit_count)

    xs_log.append(rx); ys_log.append(ry); th_log.append(th)
    dist_log.append(dist); therr_log.append(theta_err)
    v_log.append(v); w_log.append(w); wR_log.append(wR); wL_log.append(wL)

print("Simülasyon bitti.",
      f"Hedefe ulaşıldı: {reached_step is not None}, adım={reached_step}")


# =========================================================
#  2) ANİMASYON (Colab uyumlu)
# =========================================================
fig = plt.figure(figsize=(10, 7))
ax = plt.gca()
ax.set_facecolor(room_bg)
ax.set_aspect('equal', 'box')
ax.set_xlim(0, envW); ax.set_ylim(0, envH)
ax.set_xlabel("X (m)", color='w')
ax.set_ylabel("Y (m)", color='w')
ax.set_title("RRT + Lidar + 2 Tekerli Non-Holonomik Robot (Animasyon)", color='w')
ax.tick_params(colors='w')
for spine in ax.spines.values():
    spine.set_color('w')

for w in walls:
    x1,y1,x2,y2 = w
    ax.add_patch(Rectangle((x1, y1), x2-x1, y2-y1,
                           facecolor=wall_col, edgecolor=wall_col, linewidth=1.5))

ax.plot(start[0], start[1], marker='x', color=path_col, linewidth=2.5, markersize=12)
ax.plot(goal[0],  goal[1],  marker='x', color=path_col, linewidth=2.5, markersize=12)



robot_marker, = ax.plot([start[0]], [start[1]], marker='o', color=path_col,
                        markerfacecolor=path_col, markersize=8)
heading_line, = ax.plot([start[0], start[0]+0.5], [start[1], start[1]], '-', linewidth=1.5)
trail_line, = ax.plot([], [], '-', color=path_col, linewidth=2)

lidar_lines = []
for _ in range(num_beams):
    ln, = ax.plot([], [], '-', linewidth=1.2, color=lidar_col)
    lidar_lines.append(ln)

info_text = ax.text(0.02, 0.98, "", transform=ax.transAxes,
                    va='top', ha='left', color='w', fontsize=10)

Lheading = 0.6

def init_anim():
    trail_line.set_data([], [])
    for ln in lidar_lines:
        ln.set_data([], [])
    info_text.set_text("")
    return [robot_marker, heading_line, trail_line, info_text, *lidar_lines]

def update_anim(frame):
    rx = xs_log[frame]
    ry = ys_log[frame]
    th = th_log[frame]

    robot_marker.set_data([rx], [ry])

    hx = rx + Lheading*np.cos(th)
    hy = ry + Lheading*np.sin(th)
    heading_line.set_data([rx, hx], [ry, hy])

    trail_line.set_data(xs_log[:frame+1], ys_log[:frame+1])

    hit_segs = lidar_segs_log[frame]
    for i in range(num_beams):
        if i < len(hit_segs):
            x1,y1,x2,y2 = hit_segs[i]
            lidar_lines[i].set_data([x1, x2], [y1, y2])
        else:
            lidar_lines[i].set_data([], [])

    dist = dist_log[frame] if frame < len(dist_log) else np.nan
    hits = lidar_hits_log[frame] if frame < len(lidar_hits_log) else 0
    info_text.set_text(
        f"Adım: {frame+1}/{len(xs_log)}\n"
        f"Hedef mesafe: {dist:.2f} m\n"
        f"LiDAR hit: {hits}/{num_beams}"
    )

    return [robot_marker, heading_line, trail_line, info_text, *lidar_lines]

anim = FuncAnimation(fig, update_anim, frames=len(xs_log),
                     init_func=init_anim, blit=True, interval=40)

plt.close(fig)

if _HAVE_IPY:
    display(HTML(anim.to_jshtml()))
else:
    plt.show()


# =========================================================
#  3) GRAFİKLER (Metrikler)
# =========================================================
t = np.arange(len(xs_log)) * dt

plt.figure(figsize=(9,4))
plt.plot(t, dist_log)
plt.xlabel("Zaman (s)"); plt.ylabel("Hedefe Mesafe (m)")
plt.title("Hedefe Mesafe vs Zaman")
plt.grid(True); plt.tight_layout(); plt.show()

plt.figure(figsize=(9,4))
plt.plot(t[:len(therr_log)], therr_log)
plt.xlabel("Zaman (s)"); plt.ylabel("Theta Hatası (rad)")
plt.title("Heading Hatası (theta_err) vs Zaman")
plt.grid(True); plt.tight_layout(); plt.show()

plt.figure(figsize=(9,4))
plt.plot(t[:len(v_log)], v_log, label="v (m/s)")
plt.plot(t[:len(w_log)], w_log, label="w (rad/s)")
plt.xlabel("Zaman (s)"); plt.ylabel("Kontrol")
plt.title("Kontroller: v ve w")
plt.grid(True); plt.legend(); plt.tight_layout(); plt.show()

plt.figure(figsize=(9,4))
plt.plot(t[:len(wR_log)], wR_log, label="wR (rad/s)")
plt.plot(t[:len(wL_log)], wL_log, label="wL (rad/s)")
plt.xlabel("Zaman (s)"); plt.ylabel("Teker Açısal Hızı (rad/s)")
plt.title("Teker Hızları")
plt.grid(True); plt.legend(); plt.tight_layout(); plt.show()

plt.figure(figsize=(9,4))
plt.plot(t[:len(lidar_hits_log)], lidar_hits_log)
plt.xlabel("Zaman (s)"); plt.ylabel("Hit Sayısı")
plt.title("LiDAR Engelle Çarpışan Işın Sayısı vs Zaman")
plt.grid(True); plt.tight_layout(); plt.show()