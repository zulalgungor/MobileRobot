# -*- coding: utf-8 -*-
"""Colab'e hoş geldiniz.

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb


# %% =========================================================
# %  A* + LiDAR + Q-LEARNING (40x30) - 2 TEKERLİ NON-HOLONOMIC ROBOT
# %
# %  - Global yol planlama: A* (occupancy grid)
# %  - Yerel karar: Q-learning ile açısal hız w seçimi (v sabit)
# %  - Eğitim: episode reset + metrik + (opsiyonel) iz çizimi
# %  - Test: epsilon = 0 (greedy) + animasyon + LiDAR ışınları
# %
# %  EK: KAPI + BUTON + GECİKMELİ AÇILMA + ÖDÜL
# %   - 3 kapı: beyaz kalın DİKEY çizgi, başlangıçta KAPALI (occ engeli)
# %   - Her kapının yanında 1 buton: beyaz "O" (küçük)
# %   - Robot kapalı kapıya yaklaşınca hedef BUTON olur (takılma çözümü)
# %   - Robot butona yaklaşınca:
# %       * buton ödülü: +10/+20/+30 (1 kere)
# %       * açılma süreci başlar (openWaitSteps)
# %       * açılana kadar robot BEKLER (v=0, w=0)
# %       * süre bitince kapı açılır: çizgi görünmez olur, engel kalkar
# %   - Robot kapıdan geçince:
# %       * geçiş ödülü: +10/+20/+30 (1 kere)
# %   - Kapılar açıldıktan sonra KAPANMAZ (episode içinde).
# %   - A* yolu: kapılar AÇIK varsayılarak hesaplanır.
# %% =========================================================

import numpy as np
import math
import heapq
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib import patches
from matplotlib.animation import FuncAnimation
from matplotlib.collections import LineCollection
from IPython.display import HTML, display

np.random.seed(42)

# Matplotlib embed limiti (JSHTML kullanırsan lazım olabilir)
mpl.rcParams['animation.embed_limit'] = 120  # MB

# =========================================================
# 1) ROBOT PARAMETRELERİ
# =========================================================
R = 0.1   # teker yarıçapı [m]
L = 0.5   # tekerler arası [m] (bilgi)

# =========================================================
# 2) ORTAM BOYUTLARI (40 x 30 m) ve ÖLÇEKLEME (20x20 taban -> 40x30)
# =========================================================
envW, envH = 40.0, 30.0
scaleX = envW / 20.0  # 2
scaleY = envH / 20.0  # 1.5

# =========================================================
# 3) GÖRSEL AYARLAR (MATLAB benzeri)
# =========================================================
room_bg   = (0, 0, 0)
wall_col  = (0.20, 0.00, 0.35)
wall_edge = (0.20, 0.00, 0.35)
wallLW    = 0.5
path_col  = (1, 1, 1)
lidar_col = (1, 1, 0)
trainTrailColor = (0.2, 0.8, 0.8)

# =========================================================
# 4) LABİRENT DUVARLAR (20x20 taban -> 40x30)
# Duvar formatı: [x1 y1 x2 y2] (dikdörtgen)
# =========================================================
wallsBase = np.array([
    [ 2,  2,  3, 18],
    [17,  2, 18, 18],
    [ 2, 17, 18, 18],
    [ 2,  2, 18,  3],
    [ 6,  3,  7,  9],
    [ 6, 11,  7, 17],
    [10,  2, 11,  7],
    [10,  9, 11, 17],
    [14,  3, 15, 11],
    [14, 13, 15, 17],
], dtype=float)

walls = wallsBase.copy()
walls[:, [0, 2]] *= scaleX
walls[:, [1, 3]] *= scaleY

# =========================================================
# 5) KAPILAR + BUTONLAR (MATLAB’de verdiğin koordinatlar)
# Kapı çizgileri (dikey): p1=(x,y1) p2=(x,y2)
# Buton: (bx,by)
# =========================================================
doors = [
    {"p1": (13.0, 13.0), "p2": (13.0, 16.5), "button": (11.5, 15.0)},
    {"p1": (21.0, 10.0), "p2": (21.0, 13.5), "button": (19.5, 12.0)},
    {"p1": (29.0, 16.0), "p2": (29.0, 19.5), "button": (27.5, 18.0)},
]

# Dinamik kapı parametreleri (MATLAB ile aynı)
doorHalfWidth     = 0.35   # [m] kapı engel şeridi yarı kalınlık (occ mask)
buttonTriggerDist = 0.80   # [m] butona bu mesafede "basıldı"
openWaitSteps     = 8      # [step] gecikme (dt=0.2 => 1.6s)
doorApproachDist  = 1.8    # [m] kapalı kapıya yaklaşınca hedefi buton yap

# Ödüller
buttonReward = [10.0, 20.0, 30.0]
passReward   = [10.0, 20.0, 30.0]

# =========================================================
# 6) BAŞLANGIÇ ve HEDEF (20x20 taban -> 40x30)
# =========================================================
startBase = np.array([4,  6], dtype=float)
goalBase  = np.array([16, 15], dtype=float)
start = np.array([startBase[0]*scaleX, startBase[1]*scaleY], dtype=float)
goal  = np.array([goalBase[0]*scaleX,  goalBase[1]*scaleY],  dtype=float)
startPose = np.array([start[0], start[1], 0.0], dtype=float)

# =========================================================
# 7) OCCUPANCY GRID + ŞİŞİRME (DUVARLAR STATİK, KAPILAR DİNAMİK)
# =========================================================
res = 0.2
nx = int(round(envW / res))
ny = int(round(envH / res))

# Hücre merkezleri
xIdx, yIdx = np.meshgrid(np.arange(1, nx+1), np.arange(1, ny+1))
xC = (xIdx - 0.5) * res
yC = (yIdx - 0.5) * res

def wrap_to_pi(a):
    return (a + np.pi) % (2*np.pi) - np.pi

def is_collision(x, y, occ, res):
    ix = int(np.floor(x / res))
    iy = int(np.floor(y / res))
    if ix < 0 or ix >= occ.shape[1] or iy < 0 or iy >= occ.shape[0]:
        return True
    return bool(occ[iy, ix])

def force_free_around(occ, idx_xy, r_cells=2):
    ix, iy = idx_xy
    x1 = max(0, ix - r_cells); x2 = min(nx-1, ix + r_cells)
    y1 = max(0, iy - r_cells); y2 = min(ny-1, iy + r_cells)
    occ[y1:y2+1, x1:x2+1] = False
    return occ

def point_to_seg_dist(px, py, ax, ay, bx, by):
    abx, aby = bx-ax, by-ay
    apx, apy = px-ax, py-ay
    den = abx*abx + aby*aby
    if den < 1e-12:
        return math.hypot(px-ax, py-ay)
    t = (apx*abx + apy*aby) / den
    t = min(1.0, max(0.0, t))
    projx, projy = ax + t*abx, ay + t*aby
    return math.hypot(px-projx, py-projy)

def make_door_mask(p1, p2, half_width):
    """Kapı çizgisini occupancy grid üzerinde kalın bir şerit (mask) yapar."""
    ax, ay = p1
    bx, by = p2
    abx, aby = bx-ax, by-ay
    den = abx*abx + aby*aby + 1e-12

    # projeksiyon parametresi t (0..1)
    apx = xC - ax
    apy = yC - ay
    t = (apx*abx + apy*aby) / den
    t = np.clip(t, 0.0, 1.0)

    projx = ax + t*abx
    projy = ay + t*aby
    dist = np.hypot(xC - projx, yC - projy)
    return dist <= half_width

def make_circle_mask(center, rad):
    cx, cy = center
    dist = np.hypot(xC - cx, yC - cy)
    return dist <= rad

# 7.1) Duvar occ oluştur
occ_walls = np.zeros((ny, nx), dtype=bool)
for w in walls:
    inRect = (xC >= w[0]) & (xC <= w[2]) & (yC >= w[1]) & (yC <= w[3])
    occ_walls[inRect] = True

# 7.2) Şişirme (robot yarıçapı kadar)
inflateCells = int(np.ceil(R / res))
occStatic = occ_walls.copy()
ys, xs = np.where(occ_walls)
for (yy, xx) in zip(ys, xs):
    x1 = max(0, xx - inflateCells); x2 = min(nx-1, xx + inflateCells)
    y1 = max(0, yy - inflateCells); y2 = min(ny-1, yy + inflateCells)
    occStatic[y1:y2+1, x1:x2+1] = True

# 7.3) Kapı maskeleri + "şişirme kapı ağzını tıkamasın" temizliği + buton temizliği
for i, d in enumerate(doors):
    d["mask"] = make_door_mask(d["p1"], d["p2"], doorHalfWidth)

    clearHalfWidth = doorHalfWidth + (inflateCells*res) + 0.10
    clearMask = make_door_mask(d["p1"], d["p2"], clearHalfWidth)
    occStatic[clearMask] = False

    btnClearR = 0.35
    btnMask = make_circle_mask(d["button"], btnClearR)
    occStatic[btnMask] = False

# =========================================================
# 8) A* İLE GLOBAL YOL PLANLAMA (KAPILAR AÇIK VARSAYILIR)
# =========================================================
NEIGH = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]
NCOST = [1,1,1,1,math.sqrt(2),math.sqrt(2),math.sqrt(2),math.sqrt(2)]

def heuristic(a, b):
    return math.hypot(a[0]-b[0], a[1]-b[1])

def astar_grid(occ, start_idx, goal_idx):
    ny, nx = occ.shape
    sx, sy = start_idx
    gx, gy = goal_idx
    if occ[sy, sx] or occ[gy, gx]:
        return []

    gscore = np.full((ny, nx), np.inf)
    came = np.full((ny, nx, 2), -1, dtype=int)

    gscore[sy, sx] = 0.0
    pq = [(heuristic((sx,sy),(gx,gy)), (sx,sy))]
    open_set = {(sx,sy)}

    while pq:
        _, (cx, cy) = heapq.heappop(pq)
        if (cx,cy) not in open_set:
            continue
        open_set.remove((cx,cy))

        if (cx,cy) == (gx,gy):
            path = [(gx,gy)]
            px, py = gx, gy
            while not (px == sx and py == sy):
                p = came[py, px]
                if p[0] < 0:
                    return []
                px, py = int(p[0]), int(p[1])
                path.append((px,py))
            path.reverse()
            return path

        for (dxy, cst) in zip(NEIGH, NCOST):
            nx2 = cx + dxy[0]
            ny2 = cy + dxy[1]
            if nx2 < 0 or nx2 >= nx or ny2 < 0 or ny2 >= ny:
                continue
            if occ[ny2, nx2]:
                continue

            ng = gscore[cy, cx] + cst
            if ng < gscore[ny2, nx2]:
                gscore[ny2, nx2] = ng
                came[ny2, nx2] = (cx, cy)
                f = ng + heuristic((nx2,ny2), (gx,gy))
                heapq.heappush(pq, (f, (nx2,ny2)))
                open_set.add((nx2,ny2))

    return []

start_idx = (int(np.floor(start[0]/res)), int(np.floor(start[1]/res)))
goal_idx  = (int(np.floor(goal[0]/res)),  int(np.floor(goal[1]/res)))

occAstar = occStatic.copy()
occAstar = force_free_around(occAstar, start_idx, r_cells=2)
occAstar = force_free_around(occAstar, goal_idx,  r_cells=2)

path_idx = astar_grid(occAstar, start_idx, goal_idx)
if len(path_idx) == 0:
    raise RuntimeError("A* yol bulunamadı!")

path_points = np.array([[(ix+0.5)*res, (iy+0.5)*res] for (ix,iy) in path_idx], dtype=float)

# Yolu sıklaştır (5*N)
N = len(path_points)
t_old = np.arange(N)
t_new = np.linspace(0, N-1, 5*N)
x_new = np.interp(t_new, t_old, path_points[:,0])
y_new = np.interp(t_new, t_old, path_points[:,1])
path_points = np.column_stack([x_new, y_new])

# =========================================================
# 9) SİMÜLASYON + LiDAR
# =========================================================
dt = 0.2
vRef = 0.8
goalTol = 0.4

numBeams = 20
anglesBody = np.linspace(-np.pi, np.pi, numBeams)
maxRange = 3.0

def cast_ray(pos_xy, angle, occ, res, max_range):
    step = res/2.0
    x0, y0 = pos_xy
    for d in np.arange(0, max_range+1e-9, step):
        x = x0 + d*math.cos(angle)
        y = y0 + d*math.sin(angle)
        ix = int(np.floor(x/res))
        iy = int(np.floor(y/res))
        if ix < 0 or ix >= occ.shape[1] or iy < 0 or iy >= occ.shape[0]:
            return x, y, False
        if occ[iy, ix]:
            return x, y, True
    return x0 + max_range*math.cos(angle), y0 + max_range*math.sin(angle), False

def get_lidar_min(pose, anglesBody, occ, res, maxRange):
    rx, ry, th = pose
    dmin = maxRange
    for a in anglesBody:
        ga = th + a
        hx, hy, hit = cast_ray((rx,ry), ga, occ, res, maxRange)
        if hit:
            d = math.hypot(hx-rx, hy-ry)
            dmin = min(dmin, d)
    return dmin

# =========================================================
# 10) Q-LEARNING AYARLARI
# =========================================================
nD, nT, nL = 8, 9, 6
actionsW = np.array([-1.0, -0.5, 0.0, 0.5, 1.0], dtype=float)
nA = len(actionsW)
Q = np.zeros((nD, nT, nL, nA), dtype=float)

alpha = 0.2
gamma = 0.95
eps0 = 1.0
epsMin = 0.05
epsDecay = 0.995

collisionPenalty = -100.0
goalReward = 100.0
dangerPenalty = -5.0
stepPenalty = -0.1
dDanger = 0.6

maxStepsEp = 800
win = 20
targetSR = 0.85
minEpisodes = 40
maxEpisodes = 2000

# Eğitim izleri
plotTrainTrails = True
plotEveryEp = 5
KEEP_LAST_TRACES = 200
trail_stride_store = 5   # Python’da “saklama” stride

def get_state_bins(dGoal, thetaErr, dMin):
    dMax = math.hypot(envW, envH)

    dGoal = min(max(dGoal, 0.0), dMax)
    bD = int(math.floor((dGoal/dMax)*nD))
    bD = min(max(bD, 0), nD-1)

    th = wrap_to_pi(thetaErr)
    bT = int(math.floor(((th + np.pi)/(2*np.pi))*nT))
    bT = min(max(bT, 0), nT-1)

    dMin = min(max(dMin, 0.0), maxRange)
    bL = int(math.floor((dMin/maxRange)*nL))
    bL = min(max(bL, 0), nL-1)

    return (bD, bT, bL)

# =========================================================
# 11) KAPI DURUMU (episode başında resetlenir)
# =========================================================
def reset_doors_episode():
    st = []
    for i, d in enumerate(doors):
        xDoor = d["p1"][0]
        yMin = min(d["p1"][1], d["p2"][1])
        yMax = max(d["p1"][1], d["p2"][1])
        st.append({
            "isOpen": False,
            "isOpening": False,
            "tLeft": 0,
            "buttonUsed": False,
            "buttonRewardGiven": False,
            "passRewardGiven": False,
            "xDoor": xDoor,
            "yMin": yMin,
            "yMax": yMax
        })
    return st

def build_occ_now(door_state):
    """Kapalı kapıların mask’ini ekleyerek dinamik occ oluşturur."""
    doorOcc = np.zeros((ny, nx), dtype=bool)
    for i, ds in enumerate(door_state):
        if not ds["isOpen"]:
            doorOcc |= doors[i]["mask"]
    return occStatic | doorOcc

# =========================================================
# 12) EĞİTİM DÖNGÜSÜ
# =========================================================
epReturn, epSteps, epSuccess = [], [], []
train_traces = []

epsilon = eps0
ep = 0

while ep < maxEpisodes:
    ep += 1

    pose = startPose.copy()
    totalR = 0.0
    success = 0

    door_state = reset_doors_episode()
    traj = []

    for step in range(1, maxStepsEp+1):
        rx, ry, th = pose
        rExtra = 0.0

        # ---- BUTON + GECİKMELİ AÇILMA (episode içinde kalıcı açık) ----
        for i, ds in enumerate(door_state):
            # 1) Butona basma (1 kere)
            if (not ds["buttonUsed"]) and (not ds["isOpen"]) and (not ds["isOpening"]):
                bx, by = doors[i]["button"]
                dBtn = math.hypot(rx-bx, ry-by)
                if dBtn < buttonTriggerDist:
                    ds["buttonUsed"] = True
                    ds["isOpening"] = True
                    ds["tLeft"] = openWaitSteps
                    if not ds["buttonRewardGiven"]:
                        rExtra += buttonReward[i]
                        ds["buttonRewardGiven"] = True

            # 2) Açılma geri sayım
            if ds["isOpening"]:
                ds["tLeft"] -= 1
                if ds["tLeft"] <= 0:
                    ds["isOpening"] = False
                    ds["isOpen"] = True

        # ---- Dinamik occ ----
        occNow = build_occ_now(door_state)

        # Kapı açılıyorsa robot beklesin (v=w=0)
        anyOpening = any(ds["isOpening"] for ds in door_state)

        # ---- A* look-ahead hedef ----
        dists = np.linalg.norm(path_points - np.array([rx, ry]), axis=1)
        pathIdxFollow = int(np.argmin(dists))
        lookAheadIdx = min(pathIdxFollow + 20, len(path_points)-1)
        target = path_points[lookAheadIdx].copy()

        # ---- Kapalı kapıya yaklaşınca hedefi buton yap ----
        for i, ds in enumerate(door_state):
            if (not ds["isOpen"]) and (not ds["buttonUsed"]) and (not ds["isOpening"]):
                p1 = doors[i]["p1"]; p2 = doors[i]["p2"]
                dDoor = point_to_seg_dist(rx, ry, p1[0], p1[1], p2[0], p2[1])
                if dDoor < doorApproachDist:
                    bx, by = doors[i]["button"]
                    target = np.array([bx, by], dtype=float)
                    break

        # ---- heading hatası ----
        thetaDes = math.atan2(target[1]-ry, target[0]-rx)
        thetaErr = wrap_to_pi(thetaDes - th)

        # ---- lidar min ----
        dMin = get_lidar_min(pose, anglesBody, occNow, res, maxRange)

        # ---- durum ----
        dGoal = math.hypot(rx-goal[0], ry-goal[1])
        s = get_state_bins(dGoal, thetaErr, dMin)

        # ---- epsilon-greedy aksiyon ----
        if np.random.rand() < epsilon:
            a = np.random.randint(nA)
        else:
            a = int(np.argmax(Q[s[0], s[1], s[2], :]))

        # ---- bekleme kontrolü ----
        if anyOpening:
            v = 0.0
            w = 0.0
        else:
            v = vRef
            w = float(actionsW[a])

        # ---- kinematik ----
        rx2 = rx + v*math.cos(th)*dt
        ry2 = ry + v*math.sin(th)*dt
        th2 = th + w*dt
        pose2 = np.array([rx2, ry2, th2], dtype=float)

        # ---- kapı geçiş ödülü (1 kere) ----
        for i, ds in enumerate(door_state):
            if ds["isOpen"] and (not ds["passRewardGiven"]):
                yMid = 0.5*(ry + ry2)
                if (yMid >= ds["yMin"]) and (yMid <= ds["yMax"]):
                    crossed = ((rx - ds["xDoor"]) * (rx2 - ds["xDoor"]) <= 0.0)
                    if crossed:
                        rExtra += passReward[i]
                        ds["passRewardGiven"] = True

        # ---- çarpışma ----
        collision = is_collision(rx2, ry2, occNow, res)

        # ---- ödül ----
        dGoalNew = math.hypot(rx2-goal[0], ry2-goal[1])
        r = 0.0
        r += (1.0 if dGoalNew < dGoal else -1.0)  # hedefe yaklaşma
        r += stepPenalty
        if dMin < dDanger:
            r += dangerPenalty

        done = (dGoalNew < goalTol)
        if done:
            r += goalReward
        if collision:
            r += collisionPenalty

        # bonus ekle
        r += rExtra

        # ---- next state ----
        thetaDes2 = math.atan2(target[1]-ry2, target[0]-rx2)
        thetaErr2 = wrap_to_pi(thetaDes2 - th2)
        dMin2 = get_lidar_min(pose2, anglesBody, occNow, res, maxRange)
        s2 = get_state_bins(dGoalNew, thetaErr2, dMin2)

        # ---- Q update (terminal-aware) ----
        qOld = Q[s[0], s[1], s[2], a]
        if collision or done:
            targetQ = r
        else:
            targetQ = r + gamma*float(np.max(Q[s2[0], s2[1], s2[2], :]))
        Q[s[0], s[1], s[2], a] = qOld + alpha*(targetQ - qOld)

        # ---- update ----
        totalR += r
        pose = pose2
        traj.append((pose[0], pose[1]))

        if done:
            success = 1
            break
        if collision:
            break

    # ---- Eğitim izi sakla (erken bitse bile) ----
    if plotTrainTrails and (ep % trail_stride_store == 0) and len(traj) > 1:
        train_traces.append(traj)
        if len(train_traces) > KEEP_LAST_TRACES:
            train_traces = train_traces[-KEEP_LAST_TRACES:]

    # epsilon decay
    epsilon = max(epsMin, epsilon * epsDecay)

    epReturn.append(totalR)
    epSteps.append(step)
    epSuccess.append(success)

    recentSR = float(np.mean(epSuccess[-win:])) if ep >= win else float(np.mean(epSuccess))
    if ep % 10 == 0:
        print(f"Ep {ep} | Return={totalR:.1f} | Steps={step} | RecentSR={recentSR:.2f} | eps={epsilon:.2f}")

    if ep >= minEpisodes and recentSR >= targetSR:
        print(f"EĞİTİM TAMAMLANDI ✅ Ep={ep} | Son {win} ep başarı={recentSR:.2f}")
        break

epReturn  = np.array(epReturn)
epSteps   = np.array(epSteps)
epSuccess = np.array(epSuccess)

print("len(train_traces) =", len(train_traces))

# =========================================================
# 13) EĞİTİM GRAFİKLERİ
# =========================================================
plt.figure()
plt.plot(epReturn, linewidth=1.5)
plt.grid(True)
plt.xlabel("Episode")
plt.ylabel("Toplam Ödül (Return)")
plt.title("Eğitim: Episode Return")
plt.show()

plt.figure()
plt.plot(epSteps, linewidth=1.5)
plt.grid(True)
plt.xlabel("Episode")
plt.ylabel("Adım Sayısı")
plt.title("Eğitim: Episode Steps")
plt.show()

plt.figure()
win_m = 10
mov = np.convolve(epSuccess, np.ones(win_m)/win_m, mode="same")
plt.plot(mov, linewidth=1.5)
plt.grid(True)
plt.xlabel("Episode")
plt.ylabel("Başarı Oranı (10-ep ort)")
plt.title("Eğitim: Başarı Oranı")
plt.show()

# =========================================================
# 14) ÇİZİM YARDIMCILARI (duvar/kapı/buton)
# =========================================================
def setup_axes(title_text):
    fig, ax = plt.subplots(figsize=(8, 6))
    fig.patch.set_facecolor('black')
    ax.set_facecolor('black')
    ax.set_aspect('equal', adjustable='box')
    ax.set_xlim(0, envW)
    ax.set_ylim(0, envH)

    ax.tick_params(colors='white', direction='in', length=6)
    for spine in ax.spines.values():
        spine.set_color('white')
        spine.set_linewidth(1.2)

    ax.set_title(title_text, color='white')
    ax.set_xlabel("X (m)", color='white')
    ax.set_ylabel("Y (m)", color='white')
    ax.grid(False)

    # duvarlar
    for w in walls:
        rect = patches.Rectangle((w[0], w[1]), w[2]-w[0], w[3]-w[1],
                                 facecolor=wall_col, edgecolor=wall_edge, linewidth=wallLW)
        ax.add_patch(rect)

    # start/goal
    ax.plot(start[0], start[1], 'x', color=path_col, linewidth=1.6, markersize=8)
    ax.plot(goal[0],  goal[1],  'x', color=path_col, linewidth=1.6, markersize=8)

    return fig, ax

def draw_doors_and_buttons(ax, door_state):
    """Kapılar: beyaz kalın dikey çizgi. Buton: beyaz küçük O."""
    door_lines = []
    button_pts = []
    for i, d in enumerate(doors):
        p1 = d["p1"]; p2 = d["p2"]
        bx, by = d["button"]

        # kapı çizgisi (kapalıysa görünür, açılınca kaybolur)
        (ln,) = ax.plot([p1[0], p2[0]], [p1[1], p2[1]], '-', color='white', linewidth=6)
        ln.set_visible(not door_state[i]["isOpen"])
        door_lines.append(ln)

        # buton (butona basıldıysa görünmez)
        (bt,) = ax.plot(bx, by, 'o', color='white', markerfacecolor='none',
                        markersize=7, linewidth=1.6)
        bt.set_visible(not door_state[i]["buttonUsed"])
        button_pts.append(bt)

    return door_lines, button_pts

# =========================================================
# 15) TEST (epsilon=0) + ANİMASYON + LiDAR + kapı/buton dinamiği
# =========================================================
def run_test_greedy(max_steps=800):
    pose = startPose.copy()
    door_state = reset_doors_episode()

    traj = []
    lidar_segs_all = []
    door_vis_all = []    # her frame: kapı görünürlükleri
    btn_vis_all = []     # her frame: buton görünürlükleri

    for step in range(max_steps):
        rx, ry, th = pose
        traj.append((rx, ry, th))

        # görünürlük kaydı
        door_vis_all.append([not ds["isOpen"] for ds in door_state])
        btn_vis_all.append([not ds["buttonUsed"] for ds in door_state])

        if math.hypot(rx-goal[0], ry-goal[1]) < goalTol:
            break

        # buton + açılma timer
        for i, ds in enumerate(door_state):
            if (not ds["buttonUsed"]) and (not ds["isOpen"]) and (not ds["isOpening"]):
                bx, by = doors[i]["button"]
                dBtn = math.hypot(rx-bx, ry-by)
                if dBtn < buttonTriggerDist:
                    ds["buttonUsed"] = True
                    ds["isOpening"] = True
                    ds["tLeft"] = openWaitSteps

            if ds["isOpening"]:
                ds["tLeft"] -= 1
                if ds["tLeft"] <= 0:
                    ds["isOpening"] = False
                    ds["isOpen"] = True

        occNow = build_occ_now(door_state)
        anyOpening = any(ds["isOpening"] for ds in door_state)

        # look-ahead hedef
        dists = np.linalg.norm(path_points - np.array([rx, ry]), axis=1)
        pathIdxFollow = int(np.argmin(dists))
        lookAheadIdx = min(pathIdxFollow + 20, len(path_points)-1)
        target = path_points[lookAheadIdx].copy()

        # kapalı kapıya yaklaşınca buton hedefi
        for i, ds in enumerate(door_state):
            if (not ds["isOpen"]) and (not ds["buttonUsed"]) and (not ds["isOpening"]):
                p1 = doors[i]["p1"]; p2 = doors[i]["p2"]
                dDoor = point_to_seg_dist(rx, ry, p1[0], p1[1], p2[0], p2[1])
                if dDoor < doorApproachDist:
                    bx, by = doors[i]["button"]
                    target = np.array([bx, by], dtype=float)
                    break

        # state -> greedy action
        thetaDes = math.atan2(target[1]-ry, target[0]-rx)
        thetaErr = wrap_to_pi(thetaDes - th)
        dMin = get_lidar_min(pose, anglesBody, occNow, res, maxRange)
        dGoal = math.hypot(rx-goal[0], ry-goal[1])
        s = get_state_bins(dGoal, thetaErr, dMin)
        a = int(np.argmax(Q[s[0], s[1], s[2], :]))

        if anyOpening:
            v = 0.0; w = 0.0
        else:
            v = vRef; w = float(actionsW[a])

        # lidar segments (hit olanlar)
        segs = []
        for a_body in anglesBody:
            ga = th + a_body
            hx, hy, hit = cast_ray((rx,ry), ga, occNow, res, maxRange)
            if hit:
                segs.append([(rx,ry), (hx,hy)])
        lidar_segs_all.append(segs)

        # hareket
        rx2 = rx + v*math.cos(th)*dt
        ry2 = ry + v*math.sin(th)*dt
        th2 = th + w*dt

        if is_collision(rx2, ry2, occNow, res):
            break
        pose = np.array([rx2, ry2, th2], dtype=float)

    return traj, lidar_segs_all, door_vis_all, btn_vis_all

test_traj, test_lidar_segs, door_vis_all, btn_vis_all = run_test_greedy()

def animate_test():
    fig, ax = setup_axes("Test:Dinamik Ortamda A*–RL Hibrit Mobil Robot")

    # taze door state (görsel handle'lar için)
    door_state_vis = reset_doors_episode()
    door_lines, btn_pts = draw_doors_and_buttons(ax, door_state_vis)

    test_line, = ax.plot([], [], color=path_col, linewidth=2.0)
    robot_dot, = ax.plot([], [], 'o', color='white', markersize=8, markeredgecolor='black')
    head_line, = ax.plot([], [], '-', color=(0,1,0), linewidth=1.5)

    lidar_lc = LineCollection([], linewidths=1.2, colors=[lidar_col], alpha=0.9)
    ax.add_collection(lidar_lc)

    xs = [p[0] for p in test_traj]
    ys = [p[1] for p in test_traj]
    ths= [p[2] for p in test_traj]
    Lheading = 0.5

    def init():
        test_line.set_data([], [])
        robot_dot.set_data([], [])
        head_line.set_data([], [])
        lidar_lc.set_segments([])
        return (test_line, robot_dot, head_line, lidar_lc, *door_lines, *btn_pts)

    def update(i):
        test_line.set_data(xs[:i+1], ys[:i+1])
        robot_dot.set_data([xs[i]], [ys[i]])

        hx = xs[i] + Lheading*math.cos(ths[i])
        hy = ys[i] + Lheading*math.sin(ths[i])
        head_line.set_data([xs[i], hx], [ys[i], hy])

        lidar_lc.set_segments(test_lidar_segs[i] if i < len(test_lidar_segs) else [])

        # kapı/buton görünürlükleri (kayıttan)
        for k in range(3):
            door_lines[k].set_visible(door_vis_all[i][k])
            btn_pts[k].set_visible(btn_vis_all[i][k])

        return (test_line, robot_dot, head_line, lidar_lc, *door_lines, *btn_pts)

    ani = FuncAnimation(fig, update, frames=len(test_traj),
                        init_func=init, interval=40, blit=True, repeat=False)
    plt.close(fig)
    return ani

ani1 = animate_test()

# Colab'da en stabil: HTML5 video (daha küçük ve embed limitine takılmaz)
try:
    display(HTML(ani1.to_html5_video()))
except Exception:
    # ffmpeg yoksa jshtml fallback
    display(HTML(ani1.to_jshtml()))

# =========================================================
# 16) ANİMASYON 2: SADECE EĞİTİM İZLERİ (isteğe bağlı)
# =========================================================
def animate_train_traces_only(train_lw=1.2, train_alpha=0.25, trace_downsample=2):
    fig, ax = setup_axes("Eğitim İzleri: Dinamik Ortamda A*–RL Hibrit Mobil Robot Rotaları")

    # Kapıları/butonları statik olarak da göstermek istersen (hepsi kapalı gibi):
    # door_state_vis = reset_doors_episode()
    # door_lines, btn_pts = draw_doors_and_buttons(ax, door_state_vis)

    segments = []
    for p in train_traces:
        p2 = p[::trace_downsample] if trace_downsample > 1 else p
        for i in range(len(p2)-1):
            segments.append([p2[i], p2[i+1]])

    if len(segments) == 0:
        print("UYARI: train_traces boş.")
        plt.close(fig)
        return None

    lc = LineCollection([], linewidths=train_lw, alpha=train_alpha, colors=[trainTrailColor])
    ax.add_collection(lc)

    total = len(segments)
    frames = min(250, total)

    def init():
        lc.set_segments([])
        # return (lc, *door_lines, *btn_pts)
        return (lc,)

    def update(i):
        k = int((i+1) / frames * total)
        lc.set_segments(segments[:max(1, k)])
        # return (lc, *door_lines, *btn_pts)
        return (lc,)

    ani = FuncAnimation(fig, update, frames=frames, init_func=init,
                        interval=30, blit=True, repeat=False)
    plt.close(fig)
    return ani

ani2 = animate_train_traces_only(train_lw=1.6, train_alpha=0.20, trace_downsample=2)
if ani2 is not None:
    try:
        display(HTML(ani2.to_html5_video()))
    except Exception:
        display(HTML(ani2.to_jshtml()))