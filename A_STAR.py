# -*- coding: utf-8 -*-
"""Colab'e hoş geldiniz.

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb

# =========================================================
#  A* + LIDAR + 2 TEKERLİ NON-HOLONOMIC ROBOT (40x30)  - PYTHON
#  - Global yol planlama: A* (occupancy grid)
#  - Robot: diferansiyel tahrikli, non-holonomik
#  - Lidar: 20 ışın, sarı (sadece engele çarptığında çizilir)
#  - Yol: robot hareket ettikçe beyaz iz çizilir
#  + Colab uyumlu animasyon + grafikler (metrikler)
# =========================================================

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from matplotlib.animation import FuncAnimation


# -----------------------------
# Yardımcı fonksiyonlar
# -----------------------------
def wrap_to_pi(a: float) -> float:
    """Açıyı [-pi, pi] aralığına sar."""
    return (a + np.pi) % (2*np.pi) - np.pi

def force_free_around(occ: np.ndarray, idx_xy: tuple[int,int], r: int) -> np.ndarray:
    """
    Gridde start/goal çevresini zorla boşalt (sıkışmayı engeller)
    idx_xy: (x_index, y_index)  -> dikkat: x önce, y sonra
    """
    occ2 = occ.copy()
    ny, nx = occ2.shape
    cx, cy = idx_xy
    x1 = max(0, cx - r); x2 = min(nx - 1, cx + r)
    y1 = max(0, cy - r); y2 = min(ny - 1, cy + r)
    occ2[y1:y2+1, x1:x2+1] = False
    return occ2

def astar_grid(occ: np.ndarray, start_xy: tuple[int,int], goal_xy: tuple[int,int]):
    """
    A* (8-komşuluk). occ[y,x] True ise engel.
    start_xy, goal_xy: (x, y)
    Çıkış: path listesi [(x,y), ...] grid indeksleri
    """
    ny, nx = occ.shape

    neigh = np.array([[ 1, 0],[-1, 0],[0, 1],[0,-1],
                      [ 1, 1],[ 1,-1],[-1, 1],[-1,-1]], dtype=int)
    cost  = np.array([1,1,1,1,np.sqrt(2),np.sqrt(2),np.sqrt(2),np.sqrt(2)], dtype=float)

    sx, sy = start_xy
    gx, gy = goal_xy

    g = np.full((ny, nx), np.inf, dtype=float)
    f = np.full((ny, nx), np.inf, dtype=float)
    came = np.full((ny, nx), -1, dtype=int)  # parent linear index

    def heuristic(x1,y1,x2,y2):
        return np.hypot(x1-x2, y1-y2)

    g[sy, sx] = 0.0
    f[sy, sx] = heuristic(sx, sy, gx, gy)

    open_set = np.zeros((ny, nx), dtype=bool)
    open_set[sy, sx] = True

    while open_set.any():
        f_tmp = f.copy()
        f_tmp[~open_set] = np.inf
        lin = int(np.argmin(f_tmp))
        cy, cx = np.unravel_index(lin, (ny, nx))  # (y,x)

        if (cx == gx) and (cy == gy):
            path = []
            cur_lin = lin
            start_lin = sy*nx + sx
            while True:
                y, x = divmod(cur_lin, nx)
                path.append((x, y))
                if cur_lin == start_lin:
                    break
                cur_lin = came[y, x]
                if cur_lin < 0:
                    break
            path.reverse()
            return path

        open_set[cy, cx] = False

        for k in range(neigh.shape[0]):
            nx2 = cx + neigh[k,0]
            ny2 = cy + neigh[k,1]

            if nx2 < 0 or nx2 >= nx or ny2 < 0 or ny2 >= ny:
                continue
            if occ[ny2, nx2]:
                continue

            ng = g[cy, cx] + cost[k]
            if ng < g[ny2, nx2]:
                g[ny2, nx2] = ng
                f[ny2, nx2] = ng + heuristic(nx2, ny2, gx, gy)
                came[ny2, nx2] = cy*nx + cx
                open_set[ny2, nx2] = True

    return []

def cast_ray(pos_xy: tuple[float,float], angle: float, occ: np.ndarray, res: float, max_range: float):
    """
    Ray casting: engel varsa ilk çarpma noktasını döndürür.
    Çıkış: (hx, hy, hit)
    """
    ny, nx = occ.shape
    x0, y0 = pos_xy
    step = res / 2.0

    for d in np.arange(0.0, max_range + 1e-9, step):
        x = x0 + d*np.cos(angle)
        y = y0 + d*np.sin(angle)

        ix = int(np.floor(x/res))
        iy = int(np.floor(y/res))

        if ix < 0 or ix >= nx or iy < 0 or iy >= ny:
            return x0, y0, False  # harita dışı

        if occ[iy, ix]:
            return x, y, True

    return x0, y0, False

# -----------------------------
# Robot parametreleri
# -----------------------------
R = 0.1   # teker yarıçapı [m]
L = 0.5   # tekerler arası mesafe [m]

# -----------------------------
# Ortam boyutları & ölçek
# -----------------------------
envW = 40.0
envH = 30.0
scaleX = envW/20.0   # 2
scaleY = envH/20.0   # 1.5

# -----------------------------
# Renkler
# -----------------------------
room_bg   = (0, 0, 0)          # siyah
wall_col  = (0.25, 0.00, 0.40) # mor
path_col  = (1, 1, 1)          # beyaz
lidar_col = (1, 1, 0)          # sarı

# -----------------------------
# Duvarlar (20x20 taban -> 40x30 ölçek)
# -----------------------------
walls_base = []
walls_base += [
    [2,  2,  3, 18],  # sol
    [17, 2, 18, 18],  # sağ
    [2, 17, 18, 18],  # üst
    [2,  2, 18,  3],
] # alt
walls_base += [
    [6,  3,  7,  9],
    [6, 11,  7, 17],
    [10, 2, 11,  7],
    [10, 9, 11, 17],
    [14, 3, 15, 11],
    [14,13, 15, 17],
]
walls_base = np.array(walls_base, dtype=float)

walls = walls_base.copy()
walls[:, [0,2]] *= scaleX
walls[:, [1,3]] *= scaleY

# -----------------------------
# Başlangıç & hedef
# -----------------------------
start_base = np.array([4, 6], dtype=float)
goal_base  = np.array([16, 15], dtype=float)

start = np.array([start_base[0]*scaleX, start_base[1]*scaleY], dtype=float)
goal  = np.array([ goal_base[0]*scaleX,  goal_base[1]*scaleY], dtype=float)

# -----------------------------
# Occupancy grid (+ şişirme)
# -----------------------------
res = 0.2
nx = int(round(envW/res))
ny = int(round(envH/res))

occ = np.zeros((ny, nx), dtype=bool)

x_idx, y_idx = np.meshgrid(np.arange(nx), np.arange(ny))
xC = (x_idx + 0.5) * res
yC = (y_idx + 0.5) * res

for w in walls:
    x1,y1,x2,y2 = w
    in_rect = (xC >= x1) & (xC <= x2) & (yC >= y1) & (yC <= y2)
    occ[in_rect] = True

robot_radius = R
inflate_cells = int(np.ceil(robot_radius/res))

inflated = occ.copy()
ys, xs = np.where(occ)
for (yy, xx) in zip(ys, xs):
    x1 = max(0, xx - inflate_cells); x2 = min(nx-1, xx + inflate_cells)
    y1 = max(0, yy - inflate_cells); y2 = min(ny-1, yy + inflate_cells)
    inflated[y1:y2+1, x1:x2+1] = True
occ = inflated

# -----------------------------
# A* ile yol
# -----------------------------
start_idx = (int(np.floor(start[0]/res)), int(np.floor(start[1]/res))) # (x,y)
goal_idx  = (int(np.floor(goal[0]/res)),  int(np.floor(goal[1]/res)))

occ = force_free_around(occ, start_idx, r=2)
occ = force_free_around(occ, goal_idx,  r=2)

path_idx = astar_grid(occ, start_idx, goal_idx)
if len(path_idx) == 0:
    raise RuntimeError("Yol bulunamadı!")

path_idx = np.array(path_idx, dtype=float)
x_path = (path_idx[:,0] + 0.5) * res
y_path = (path_idx[:,1] + 0.5) * res
path_points = np.column_stack([x_path, y_path])

# yolu sıklaştır (5x)
N = path_points.shape[0]
t_old = np.arange(N)
t_new = np.linspace(0, N-1, 5*N)
path_points = np.column_stack([
    np.interp(t_new, t_old, path_points[:,0]),
    np.interp(t_new, t_old, path_points[:,1]),
])

# =========================================================
#  1) SİMÜLASYONU ÇALIŞTIR + LOG TOPLA
# =========================================================
dt = 0.2
v_ref = 0.8
k_theta = 1.5
goal_tol = 0.4
max_steps = 3000

max_range = 3.0
num_beams = 20
angles_body = np.linspace(-np.pi, np.pi, num_beams)

pose = np.array([start[0], start[1], 0.0], dtype=float)

# Loglar
xs_log, ys_log, th_log = [], [], []
dist_log, therr_log = [], []
v_log, w_log, wR_log, wL_log = [], [], [], []
lidar_hits_log = []               # o adımda kaç ışın engele çarptı
lidar_segs_log = []               # her adım: [(x1,y1,x2,y2), ...] sadece hit olanlar

reached_step = None

for step in range(1, max_steps+1):
    rx, ry, th = pose

    # hedef metrikleri
    dist = float(np.hypot(rx - goal[0], ry - goal[1]))

    # hedef kontrol
    if dist < goal_tol:
        reached_step = step
        # bu adım için lidar boş kaydet
        lidar_segs_log.append([])
        lidar_hits_log.append(0)
        # logla ve bitir
        xs_log.append(rx); ys_log.append(ry); th_log.append(th)
        dist_log.append(dist); therr_log.append(0.0)
        v_log.append(0.0); w_log.append(0.0); wR_log.append(0.0); wL_log.append(0.0)
        break

    # path üzerinde en yakın + look-ahead
    dists = np.hypot(path_points[:,0] - rx, path_points[:,1] - ry)
    path_idx_follow = int(np.argmin(dists))
    look_ahead_idx = min(path_idx_follow + 20, path_points.shape[0] - 1)
    target = path_points[look_ahead_idx]

    # heading kontrol
    dx = target[0] - rx
    dy = target[1] - ry
    theta_des = float(np.arctan2(dy, dx))
    theta_err = float(wrap_to_pi(theta_des - th))

    v = float(v_ref)
    w = float(np.clip(k_theta * theta_err, -1.0, 1.0))

    # non-holonomic güncelleme
    rx = rx + v*np.cos(th)*dt
    ry = ry + v*np.sin(th)*dt
    th = th + w*dt
    pose = np.array([rx, ry, th], dtype=float)

    # teker hızları
    wR = float((2*v + L*w) / (2*R))
    wL = float((2*v - L*w) / (2*R))

    # LiDAR: sadece hit olan segmentleri sakla
    hit_segs = []
    hit_count = 0
    for ab in angles_body:
        global_ang = th + ab
        hx, hy, hit = cast_ray((rx, ry), global_ang, occ, res, max_range)
        if hit:
            hit_count += 1
            hit_segs.append((rx, ry, hx, hy))
    lidar_segs_log.append(hit_segs)
    lidar_hits_log.append(hit_count)

    # logları yaz
    xs_log.append(rx); ys_log.append(ry); th_log.append(th)
    dist_log.append(dist); therr_log.append(theta_err)
    v_log.append(v); w_log.append(w); wR_log.append(wR); wL_log.append(wL)

print("Simülasyon bitti.",
      f"Hedefe ulaşıldı: {reached_step is not None}, adım={reached_step}")


# =========================================================
#  2) ANİMASYON (Colab uyumlu)
# =========================================================
fig = plt.figure(figsize=(10, 7))
ax = plt.gca()
ax.set_facecolor(room_bg)
ax.set_aspect('equal', 'box')
ax.set_xlim(0, envW); ax.set_ylim(0, envH)
ax.set_xlabel("X (m)", color='w')
ax.set_ylabel("Y (m)", color='w')
ax.set_title("A* + Lidar + 2 Tekerli Non-Holonomik Robot (Animasyon)", color='w')
ax.tick_params(colors='w')
for spine in ax.spines.values():
    spine.set_color('w')

# duvarlar
for w in walls:
    x1,y1,x2,y2 = w
    ax.add_patch(Rectangle((x1, y1), x2-x1, y2-y1,
                           facecolor=wall_col, edgecolor=wall_col, linewidth=1.5))

# start/goal
ax.plot(start[0], start[1], marker='x', color=path_col, linewidth=2.5, markersize=12)
ax.plot(goal[0],  goal[1],  marker='x', color=path_col, linewidth=2.5, markersize=12)

# robot + heading + trail
robot_marker, = ax.plot([start[0]], [start[1]], marker='o', color=path_col,
                        markerfacecolor=path_col, markersize=8)
heading_line, = ax.plot([start[0], start[0]+0.5], [start[1], start[1]], '-', linewidth=1.5)

trail_line, = ax.plot([], [], '-', color=path_col, linewidth=2)

# lidar çizgileri: sabit 20 line objesi
lidar_lines = []
for _ in range(num_beams):
    ln, = ax.plot([], [], '-', linewidth=1.2, color=lidar_col)
    lidar_lines.append(ln)

# bilgi yazısı (adım, mesafe, hit sayısı)
info_text = ax.text(0.02, 0.98, "", transform=ax.transAxes,
                    va='top', ha='left', color='w', fontsize=10)

Lheading = 0.6

def init_anim():
    trail_line.set_data([], [])
    for ln in lidar_lines:
        ln.set_data([], [])
    info_text.set_text("")
    return [robot_marker, heading_line, trail_line, info_text, *lidar_lines]

def update_anim(frame):
    rx = xs_log[frame]
    ry = ys_log[frame]
    th = th_log[frame]

    # robot
    robot_marker.set_data([rx], [ry])

    # heading
    hx = rx + Lheading*np.cos(th)
    hy = ry + Lheading*np.sin(th)
    heading_line.set_data([rx, hx], [ry, hy])

    # trail
    trail_line.set_data(xs_log[:frame+1], ys_log[:frame+1])

    # lidar: sadece hit segmentlerini çiz, kalanları boşalt
    hit_segs = lidar_segs_log[frame]
    for i in range(num_beams):
        if i < len(hit_segs):
            x1,y1,x2,y2 = hit_segs[i]
            lidar_lines[i].set_data([x1, x2], [y1, y2])
        else:
            lidar_lines[i].set_data([], [])

    # bilgi metni
    dist = dist_log[frame] if frame < len(dist_log) else np.nan
    hits = lidar_hits_log[frame] if frame < len(lidar_hits_log) else 0
    info_text.set_text(f"Adım: {frame+1}/{len(xs_log)}\nHedef mesafe: {dist:.2f} m\nLiDAR hit: {hits}/{num_beams}")

    return [robot_marker, heading_line, trail_line, info_text, *lidar_lines]

# interval: ms (animasyon hızı). yavaşlatmak için büyüt (örn 60-100)
anim = FuncAnimation(fig, update_anim, frames=len(xs_log),
                     init_func=init_anim, blit=True, interval=40)

plt.close(fig)  # Colab'da çift figür çıkmasını engeller

if _HAVE_IPY:
    # Colab / notebook içinde göster
    display(HTML(anim.to_jshtml()))
else:
    # normal python ortamı
    plt.show()


# =========================================================
#  3) GRAFİKLER (Metrikler)
# =========================================================
t = np.arange(len(xs_log)) * dt

# 1) Hedefe mesafe
plt.figure(figsize=(9,4))
plt.plot(t, dist_log)
plt.xlabel("Zaman (s)")
plt.ylabel("Hedefe Mesafe (m)")
plt.title("Hedefe Mesafe vs Zaman")
plt.grid(True)
plt.tight_layout()
plt.show()

# 2) Heading hatası
plt.figure(figsize=(9,4))
plt.plot(t[:len(therr_log)], therr_log)
plt.xlabel("Zaman (s)")
plt.ylabel("Theta Hatası (rad)")
plt.title("Heading Hatası (theta_err) vs Zaman")
plt.grid(True)
plt.tight_layout()
plt.show()

# 3) Kontrol girişleri v ve w
plt.figure(figsize=(9,4))
plt.plot(t[:len(v_log)], v_log, label="v (m/s)")
plt.plot(t[:len(w_log)], w_log, label="w (rad/s)")
plt.xlabel("Zaman (s)")
plt.ylabel("Kontrol")
plt.title("Kontroller: v ve w")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# 4) Teker hızları
plt.figure(figsize=(9,4))
plt.plot(t[:len(wR_log)], wR_log, label="wR (rad/s)")
plt.plot(t[:len(wL_log)], wL_log, label="wL (rad/s)")
plt.xlabel("Zaman (s)")
plt.ylabel("Teker Açısal Hızı (rad/s)")
plt.title("Teker Hızları")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# 5) LiDAR hit sayısı (yakın engel yoğunluğu gibi düşün)
plt.figure(figsize=(9,4))
plt.plot(t[:len(lidar_hits_log)], lidar_hits_log)
plt.xlabel("Zaman (s)")
plt.ylabel("Hit Sayısı")
plt.title("LiDAR Engelle Çarpışan Işın Sayısı vs Zaman")
plt.grid(True)
plt.tight_layout()
plt.show()