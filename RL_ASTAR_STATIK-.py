# -*- coding: utf-8 -*-
"""Colab'e hoş geldiniz.

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

# -*- coding: utf-8 -*-
"""Colab'e hoş geldiniz.

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

# %% =========================================================
# %  FINAL ÖDEVİ
# %  RL TABANLI LİDAR DESTEKLİ NON-HOLANOMİK MOBİL ROBOT
# %
# %  - Global yol planlama: A* (occupancy grid)
# %  - Yerel karar: Q-learning ile açısal hız w seçimi (v sabit)
# %  - Eğitim: episode reset + metrik + (opsiyonel) iz çizimi
# %  - Test: epsilon = 0 (greedy) + animasyon + LiDAR ışınları
# %% =========================================================

import numpy as np
import math
import heapq
import matplotlib.pyplot as plt
from matplotlib import patches
from matplotlib.animation import FuncAnimation
from matplotlib.collections import LineCollection
from IPython.display import HTML, display

np.random.seed(42)

# =========================================================
# 1) ROBOT PARAMETRELERİ
# =========================================================
R = 0.1  # teker yarıçapı [m]
L = 0.5  # tekerler arası mesafe [m]

# =========================================================
# 2) ORTAM BOYUTLARI (40 x 30 m) ve ÖLÇEKLEME
#    - Duvarlar 20x20 taban koordinatta tanımlıdır
#    - 40x30'a ölçeklenir
# =========================================================
envW, envH = 40.0, 30.0
scaleX = envW / 20.0   # 2.0
scaleY = envH / 20.0   # 1.5

# =========================================================
# 3) GÖRSEL AYARLAR
# =========================================================
room_bg   = (0, 0, 0)
wall_col  = (0.20, 0.00, 0.35)
wall_edge = (0.20, 0.00, 0.35)
wallLW    = 0.5
path_col  = (1, 1, 1)
lidar_col = (1, 1, 0)
trainTrailColor = (0.2, 0.8, 0.8)  # camgöbeği

# =========================================================
# 4) LABİRENT (DUVARLAR) - TABAN 20x20 -> 40x30
# Duvar formatı: [x1 y1 x2 y2] (dikdörtgen)
# =========================================================
wallsBase = []
# dış sınırlar
wallsBase.append([ 2,  2,  3, 18])
wallsBase.append([17,  2, 18, 18])
wallsBase.append([ 2, 17, 18, 18])
wallsBase.append([ 2,  2, 18,  3])

# iç duvarlar
wallsBase.append([ 6,  3,  7,  9])
wallsBase.append([ 6, 11,  7, 17])
wallsBase.append([10,  2, 11,  7])
wallsBase.append([10,  9, 11, 17])
wallsBase.append([14,  3, 15, 11])
wallsBase.append([14, 13, 15, 17])

wallsBase = np.array(wallsBase, dtype=float)

# ölçekle
walls = wallsBase.copy()
walls[:, [0, 2]] *= scaleX
walls[:, [1, 3]] *= scaleY

# =========================================================
# 5) BAŞLANGIÇ ve HEDEF (20x20 taban -> 40x30)
# =========================================================
startBase = np.array([4,  6], dtype=float)
goalBase  = np.array([16, 15], dtype=float)

start = np.array([startBase[0]*scaleX, startBase[1]*scaleY], dtype=float)
goal  = np.array([goalBase[0]*scaleX,  goalBase[1]*scaleY],  dtype=float)

# =========================================================
# 6) OCCUPANCY GRID OLUŞTURMA + ŞİŞİRME (inflate)
#    - res = 0.2 m grid çözünürlüğü
#    - duvarlar grid'e işaretlenir
#    - robot yarıçapı kadar şişirilir
# =========================================================
res = 0.2
nx = int(round(envW / res))
ny = int(round(envH / res))
occ = np.zeros((ny, nx), dtype=bool)

# Hücre merkezleri
xIdx, yIdx = np.meshgrid(np.arange(1, nx+1), np.arange(1, ny+1))
xC = (xIdx - 0.5) * res
yC = (yIdx - 0.5) * res

# duvar içi hücreleri doldur
for w in walls:
    inRect = (xC >= w[0]) & (xC <= w[2]) & (yC >= w[1]) & (yC <= w[3])
    occ[inRect] = True

# inflate (robot yarıçapı kadar)
robotRadius = R
inflateCells = int(np.ceil(robotRadius / res))
inflated = occ.copy()
ys, xs = np.where(occ)
for (yy, xx) in zip(ys, xs):
    x1 = max(0, xx - inflateCells); x2 = min(nx-1, xx + inflateCells)
    y1 = max(0, yy - inflateCells); y2 = min(ny-1, yy + inflateCells)
    inflated[y1:y2+1, x1:x2+1] = True
occ = inflated

# =========================================================
# 7) YARDIMCI FONKSİYONLAR
# =========================================================
def wrap_to_pi(a):
    """Açıyı [-pi, pi] aralığına sarar."""
    return (a + np.pi) % (2*np.pi) - np.pi

def is_collision(x, y, occ, res):
    """(x,y) konumu gridde dolu hücreye denk geliyorsa çarpışma True."""
    ix = int(np.floor(x / res))
    iy = int(np.floor(y / res))
    if ix < 0 or ix >= occ.shape[1] or iy < 0 or iy >= occ.shape[0]:
        return True
    return bool(occ[iy, ix])

def force_free_around(occ, idx_xy, r_cells=2):
    """Start/goal çevresinde küçük bir alanı serbest yapar (inflate yüzünden kapanmasın)."""
    ix, iy = idx_xy
    x1 = max(0, ix - r_cells); x2 = min(occ.shape[1]-1, ix + r_cells)
    y1 = max(0, iy - r_cells); y2 = min(occ.shape[0]-1, iy + r_cells)
    occ[y1:y2+1, x1:x2+1] = False
    return occ

# =========================================================
# 8) A* GLOBAL YOL PLANLAMA (8-connected)
# =========================================================
NEIGH = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]
NCOST = [1,1,1,1,math.sqrt(2),math.sqrt(2),math.sqrt(2),math.sqrt(2)]

def heuristic(a, b):
    return math.hypot(a[0]-b[0], a[1]-b[1])

def astar_grid(occ, start_idx, goal_idx):
    """Occupancy grid üzerinde A* (8 bağlı komşuluk). Path: (ix,iy) listesi."""
    ny, nx = occ.shape
    sx, sy = start_idx
    gx, gy = goal_idx

    if occ[sy, sx] or occ[gy, gx]:
        return []

    gscore = np.full((ny, nx), np.inf)
    came_from = np.full((ny, nx, 2), -1, dtype=int)

    gscore[sy, sx] = 0.0
    pq = []
    heapq.heappush(pq, (heuristic((sx,sy),(gx,gy)), (sx,sy)))
    in_open = set([(sx,sy)])

    while pq:
        _, (cx, cy) = heapq.heappop(pq)
        if (cx,cy) not in in_open:
            continue
        in_open.remove((cx,cy))

        if (cx,cy) == (gx,gy):
            # path reconstruct
            path = [(gx,gy)]
            px, py = gx, gy
            while not (px == sx and py == sy):
                p = came_from[py, px]
                if p[0] < 0:
                    return []
                px, py = int(p[0]), int(p[1])
                path.append((px,py))
            path.reverse()
            return path

        for (d, cst) in zip(NEIGH, NCOST):
            nx2 = cx + d[0]
            ny2 = cy + d[1]
            if nx2 < 0 or nx2 >= nx or ny2 < 0 or ny2 >= ny:
                continue
            if occ[ny2, nx2]:
                continue

            ng = gscore[cy, cx] + cst
            if ng < gscore[ny2, nx2]:
                gscore[ny2, nx2] = ng
                came_from[ny2, nx2] = (cx, cy)
                f = ng + heuristic((nx2,ny2),(gx,gy))
                heapq.heappush(pq, (f, (nx2,ny2)))
                in_open.add((nx2,ny2))

    return []

# start/goal grid indeksleri (0-based)
start_idx = (int(np.floor(start[0]/res)), int(np.floor(start[1]/res)))
goal_idx  = (int(np.floor(goal[0]/res)),  int(np.floor(goal[1]/res)))

occ = force_free_around(occ, start_idx, r_cells=2)
occ = force_free_around(occ, goal_idx,  r_cells=2)

path_idx = astar_grid(occ, start_idx, goal_idx)
if len(path_idx) == 0:
    raise RuntimeError("A* yol bulunamadı!")

# grid idx -> metre (0-based: (idx+0.5)*res)
path_points = np.array([[(ix+0.5)*res, (iy+0.5)*res] for (ix,iy) in path_idx], dtype=float)

# yolu sıklaştır (daha yumuşak takip için)
N = len(path_points)
t_old = np.arange(N)
t_new = np.linspace(0, N-1, 5*N)
x_new = np.interp(t_new, t_old, path_points[:,0])
y_new = np.interp(t_new, t_old, path_points[:,1])
path_points = np.column_stack([x_new, y_new])

# =========================================================
# 9) SİMÜLASYON + LiDAR
# =========================================================
dt = 0.2
vRef = 0.8
goalTol = 0.4

numBeams = 20
anglesBody = np.linspace(-np.pi, np.pi, numBeams)
maxRange = 3.0

startPose = np.array([start[0], start[1], 0.0], dtype=float)

def cast_ray(pos_xy, angle, occ, res, max_range):
    """Ray-casting: (x,y)den angle doğrultusunda engel bulunca döner."""
    step = res/2.0
    x0, y0 = pos_xy
    for d in np.arange(0, max_range+1e-9, step):
        x = x0 + d*math.cos(angle)
        y = y0 + d*math.sin(angle)
        ix = int(np.floor(x/res))
        iy = int(np.floor(y/res))
        if ix < 0 or ix >= occ.shape[1] or iy < 0 or iy >= occ.shape[0]:
            return x, y, False
        if occ[iy, ix]:
            return x, y, True
    return x0 + max_range*math.cos(angle), y0 + max_range*math.sin(angle), False

def get_lidar_min(pose, anglesBody, occ, res, maxRange):
    """Tüm ışınlar içinde minimum çarpma mesafesi."""
    rx, ry, th = pose
    dmin = maxRange
    for a in anglesBody:
        ga = th + a
        hx, hy, hit = cast_ray((rx,ry), ga, occ, res, maxRange)
        if hit:
            d = math.hypot(hx-rx, hy-ry)
            dmin = min(dmin, d)
    return dmin

# =========================================================
# 10) Q-LEARNING PARAMETRELERİ
#    - state bins: nD=8, nT=9, nL=6
#    - actionsW = [-1, -0.5, 0, 0.5, 1]
# =========================================================
nD, nT, nL = 8, 9, 6
actionsW = np.array([-1.0, -0.5, 0.0, 0.5, 1.0], dtype=float)
nA = len(actionsW)

Q = np.zeros((nD, nT, nL, nA), dtype=float)

alpha = 0.2
gamma = 0.95

eps0 = 1.0
epsMin = 0.05
epsDecay = 0.995

collisionPenalty = -100.0
goalReward = 100.0
dangerPenalty = -5.0
stepPenalty = -0.1
dDanger = 0.6

maxStepsEp = 800
win = 20
targetSR = 0.85
minEpisodes = 40
maxEpisodes = 1000

# Eğitim izleri (FIX: eğitim erken bitse bile saklanır)
plotTrainTrails = True
trail_stride_store = 5
KEEP_LAST_TRACES = 200

def get_state_bins(dGoal, thetaErr, dMin, nD, nT, nL, maxRange, envW, envH):
    """Sürekli değerleri ayrık binlere çevirir."""
    dMax = math.hypot(envW, envH)

    dGoal = min(max(dGoal, 0.0), dMax)
    bD = int(math.floor((dGoal/dMax)*nD))
    bD = min(max(bD, 0), nD-1)

    th = wrap_to_pi(thetaErr)
    bT = int(math.floor(((th + np.pi)/(2*np.pi))*nT))
    bT = min(max(bT, 0), nT-1)

    dMin = min(max(dMin, 0.0), maxRange)
    bL = int(math.floor((dMin/maxRange)*nL))
    bL = min(max(bL, 0), nL-1)

    return (bD, bT, bL)

# =========================================================
# 11) EĞİTİM DÖNGÜSÜ
# =========================================================
epReturn  = []
epSteps   = []
epSuccess = []
train_traces = []

epsilon = eps0
ep = 0

while ep < maxEpisodes:
    ep += 1
    pose = startPose.copy()
    totalR = 0.0
    success = 0
    traj = []

    for step in range(1, maxStepsEp+1):
        rx, ry, th = pose

        # A* yolunda look-ahead hedef
        dists = np.linalg.norm(path_points - np.array([rx, ry]), axis=1)
        pathIdxFollow = int(np.argmin(dists))
        lookAheadIdx = min(pathIdxFollow + 20, len(path_points)-1)
        target = path_points[lookAheadIdx]

        thetaDes = math.atan2(target[1]-ry, target[0]-rx)
        thetaErr = wrap_to_pi(thetaDes - th)

        dMin = get_lidar_min(pose, anglesBody, occ, res, maxRange)

        dGoal = math.hypot(rx-goal[0], ry-goal[1])
        s = get_state_bins(dGoal, thetaErr, dMin, nD, nT, nL, maxRange, envW, envH)

        # epsilon-greedy aksiyon seçimi
        if np.random.rand() < epsilon:
            a = np.random.randint(nA)
        else:
            a = int(np.argmax(Q[s[0], s[1], s[2], :]))

        v = vRef
        w = actionsW[a]

        # non-holonomic kinematik
        rx2 = rx + v*math.cos(th)*dt
        ry2 = ry + v*math.sin(th)*dt
        th2 = th + w*dt
        pose2 = np.array([rx2, ry2, th2], dtype=float)

        collision = is_collision(rx2, ry2, occ, res)

        # ödül tasarımı
        dGoalNew = math.hypot(rx2-goal[0], ry2-goal[1])
        r = 0.0
        r += (1.0 if dGoalNew < dGoal else -1.0)   # hedefe yaklaşma
        r += stepPenalty                            # her adım cezası
        if dMin < dDanger:
            r += dangerPenalty                       # duvara yakın ceza

        done = (dGoalNew < goalTol)
        if done:
            r += goalReward
        if collision:
            r += collisionPenalty

        # sonraki durum
        thetaDes2 = math.atan2(target[1]-ry2, target[0]-rx2)
        thetaErr2 = wrap_to_pi(thetaDes2 - th2)
        dMin2 = get_lidar_min(pose2, anglesBody, occ, res, maxRange)
        s2 = get_state_bins(dGoalNew, thetaErr2, dMin2, nD, nT, nL, maxRange, envW, envH)

        # Q update (terminal-aware)
        qOld = Q[s[0], s[1], s[2], a]
        if collision or done:
            targetQ = r
        else:
            targetQ = r + gamma*float(np.max(Q[s2[0], s2[1], s2[2], :]))
        Q[s[0], s[1], s[2], a] = qOld + alpha*(targetQ - qOld)

        # kayıt
        totalR += r
        pose = pose2
        traj.append((pose[0], pose[1]))

        if done:
            success = 1
            break
        if collision:
            break

    # ---- Eğitim izi kaydı (FIX) ----
    # Eğitim kaçıncı epizde biterse bitsin, stride'a göre saklarız
    if plotTrainTrails and (ep % trail_stride_store == 0) and len(traj) > 1:
        train_traces.append(traj)
        if len(train_traces) > KEEP_LAST_TRACES:
            train_traces = train_traces[-KEEP_LAST_TRACES:]

    # epsilon decay
    epsilon = max(epsMin, epsilon * epsDecay)

    # metrikler
    epReturn.append(totalR)
    epSteps.append(step)
    epSuccess.append(success)

    recentSR = float(np.mean(epSuccess[-win:])) if ep >= win else float(np.mean(epSuccess))
    if ep % 10 == 0:
        print(f"Ep {ep} | Return={totalR:.1f} | Steps={step} | RecentSR={recentSR:.2f} | eps={epsilon:.2f}")

    # erken durdurma
    if ep >= minEpisodes and recentSR >= targetSR:
        print(f"EĞİTİM TAMAMLANDI ✅ Ep={ep} | Son {win} ep başarı={recentSR:.2f}")
        break

epReturn  = np.array(epReturn)
epSteps   = np.array(epSteps)
epSuccess = np.array(epSuccess)

print("len(train_traces) =", len(train_traces))

# =========================================================
# 12) EĞİTİM GRAFİKLERİ
# =========================================================
plt.figure()
plt.plot(epReturn, linewidth=1.5)
plt.grid(True)
plt.xlabel("Episode")
plt.ylabel("Toplam Ödül (Return)")
plt.title("Eğitim: Episode Return")
plt.show()

plt.figure()
plt.plot(epSteps, linewidth=1.5)
plt.grid(True)
plt.xlabel("Episode")
plt.ylabel("Adım Sayısı")
plt.title("Eğitim: Episode Steps")
plt.show()

plt.figure()
win_m = 10
mov = np.convolve(epSuccess, np.ones(win_m)/win_m, mode="same")
plt.plot(mov, linewidth=1.5)
plt.grid(True)
plt.xlabel("Episode")
plt.ylabel("Başarı Oranı (10-ep ort)")
plt.title("Eğitim: Başarı Oranı")
plt.show()

# =========================================================
# 13) ÇİZİM YARDIMCILARI
# =========================================================
def draw_walls(ax, walls):
    """Duvarları rectangle olarak çizer."""
    for w in walls:
        rect = patches.Rectangle((w[0], w[1]), w[2]-w[0], w[3]-w[1],
                                 facecolor=wall_col, edgecolor=wall_edge, linewidth=wallLW)
        ax.add_patch(rect)

# =========================================================
# 14) ANİMASYON 1: TEST (epsilon=0) + LiDAR IŞINLARI
# =========================================================
def run_test_greedy(max_steps=800):
    """Eğitim sonrası greedy politika ile test koşusu."""
    pose = startPose.copy()
    traj = []
    lidar_hits_all = []

    for _ in range(max_steps):
        rx, ry, th = pose
        traj.append((rx, ry, th))

        if math.hypot(rx-goal[0], ry-goal[1]) < goalTol:
            break

        dists = np.linalg.norm(path_points - np.array([rx, ry]), axis=1)
        pathIdxFollow = int(np.argmin(dists))
        lookAheadIdx = min(pathIdxFollow + 20, len(path_points)-1)
        target = path_points[lookAheadIdx]

        thetaDes = math.atan2(target[1]-ry, target[0]-rx)
        thetaErr = wrap_to_pi(thetaDes - th)
        dMin = get_lidar_min(pose, anglesBody, occ, res, maxRange)
        dGoal = math.hypot(rx-goal[0], ry-goal[1])
        s = get_state_bins(dGoal, thetaErr, dMin, nD, nT, nL, maxRange, envW, envH)

        a = int(np.argmax(Q[s[0], s[1], s[2], :]))
        v = vRef
        w = actionsW[a]

        # lidar segmentleri (sadece hit olanlar)
        segs = []
        for a_body in anglesBody:
            ga = th + a_body
            hx, hy, hit = cast_ray((rx,ry), ga, occ, res, maxRange)
            if hit:
                segs.append([(rx,ry), (hx,hy)])
        lidar_hits_all.append(segs)

        rx2 = rx + v*math.cos(th)*dt
        ry2 = ry + v*math.sin(th)*dt
        th2 = th + w*dt

        if is_collision(rx2, ry2, occ, res):
            break
        pose = np.array([rx2, ry2, th2], dtype=float)

    return traj, lidar_hits_all

test_traj, test_lidar_segs = run_test_greedy()

def animate_test_with_lidar():
    """Test animasyonu: robot + iz + lidar ışınları."""
    fig, ax = plt.subplots(figsize=(8, 6))
    fig.patch.set_facecolor('black')
    ax.set_facecolor('black')
    ax.set_aspect('equal', adjustable='box')
    ax.set_xlim(0, envW); ax.set_ylim(0, envH)

    ax.tick_params(colors='white', direction='in', length=6)
    for spine in ax.spines.values():
        spine.set_color('white'); spine.set_linewidth(1.2)

    ax.set_title("Test (Greedy) + LiDAR Işınları", color='white')
    ax.set_xlabel("X (m)", color='white')
    ax.set_ylabel("Y (m)", color='white')
    ax.grid(False)

    draw_walls(ax, walls)
    ax.plot(start[0], start[1], 'x', color=path_col, linewidth=1.6, markersize=8)
    ax.plot(goal[0],  goal[1],  'x', color=path_col, linewidth=1.6, markersize=8)

    test_line, = ax.plot([], [], color=path_col, linewidth=2.0)
    robot_dot, = ax.plot([], [], 'o', color='white', markersize=7, markeredgecolor='black')
    head_line, = ax.plot([], [], '-', color=(0,1,0), linewidth=1.2)

    lidar_lc = LineCollection([], linewidths=1.0, colors=[lidar_col], alpha=0.9)
    ax.add_collection(lidar_lc)

    xs = [p[0] for p in test_traj]
    ys = [p[1] for p in test_traj]
    ths= [p[2] for p in test_traj]
    Lheading = 0.5

    def init():
        test_line.set_data([], [])
        robot_dot.set_data([], [])
        head_line.set_data([], [])
        lidar_lc.set_segments([])
        return test_line, robot_dot, head_line, lidar_lc

    def update(i):
        test_line.set_data(xs[:i+1], ys[:i+1])
        robot_dot.set_data([xs[i]], [ys[i]])

        hx = xs[i] + Lheading*math.cos(ths[i])
        hy = ys[i] + Lheading*math.sin(ths[i])
        head_line.set_data([xs[i], hx], [ys[i], hy])

        lidar_lc.set_segments(test_lidar_segs[i] if i < len(test_lidar_segs) else [])
        return test_line, robot_dot, head_line, lidar_lc

    ani = FuncAnimation(fig, update, frames=len(test_traj),
                        init_func=init, interval=40, blit=True, repeat=False)
    plt.close(fig)
    return ani

# =========================================================
# 15) ANİMASYON 2: SADECE EĞİTİM İZLERİ (İNCE ÇİZGİ)
#    - Robot yok
#    - LiDAR yok
#    - Sadece camgöbeği izler
# =========================================================
def animate_train_traces_only(train_lw=0.30, train_alpha=0.35, trace_downsample=2):
    """Eğitim izlerini progressive olarak çizen animasyon (hafif ve stabil)."""
    fig, ax = plt.subplots(figsize=(8, 6))
    fig.patch.set_facecolor('black')
    ax.set_facecolor('black')
    ax.set_aspect('equal', adjustable='box')
    ax.set_xlim(0, envW); ax.set_ylim(0, envH)

    ax.tick_params(colors='white', direction='in', length=6)
    for spine in ax.spines.values():
        spine.set_color('white'); spine.set_linewidth(1.2)

    ax.set_title("Eğitim İzleri (Q-Learning)", color='white')
    ax.set_xlabel("X (m)", color='white')
    ax.set_ylabel("Y (m)", color='white')
    ax.grid(False)

    draw_walls(ax, walls)
    ax.plot(start[0], start[1], 'x', color=path_col, linewidth=1.6, markersize=8)
    ax.plot(goal[0],  goal[1],  'x', color=path_col, linewidth=1.6, markersize=8)

    # tüm izleri segmente çevir
    segments = []
    for p in train_traces:
        p2 = p[::trace_downsample] if trace_downsample > 1 else p
        for i in range(len(p2)-1):
            segments.append([p2[i], p2[i+1]])

    if len(segments) == 0:
        print("UYARI: train_traces boş. (len(train_traces)=0 olabilir)")
        plt.close(fig)
        return None

    lc = LineCollection([], linewidths=train_lw, alpha=train_alpha, colors=[trainTrailColor])
    ax.add_collection(lc)

    total = len(segments)
    frames = min(250, total)  # çok büyümesin

    def init():
        lc.set_segments([])
        return (lc,)

    def update(i):
        k = int((i+1) / frames * total)
        lc.set_segments(segments[:max(1, k)])
        return (lc,)

    ani = FuncAnimation(fig, update, frames=frames, init_func=init,
                        interval=30, blit=True, repeat=False)
    plt.close(fig)
    return ani

# =========================================================
# 16) ÇALIŞTIR / GÖSTER
# =========================================================
ani1 = animate_test_with_lidar()
display(HTML(ani1.to_jshtml()))

ani2 = animate_train_traces_only(train_lw=0.25, train_alpha=0.30, trace_downsample=2)
if ani2 is not None:
    display(HTML(ani2.to_jshtml()))